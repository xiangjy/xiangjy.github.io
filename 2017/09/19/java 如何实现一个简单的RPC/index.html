
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Xiangjy&#39;s Blog">
    <title>Java 如何实现一个简单的RPC - Xiangjy&#39;s Blog</title>
    <meta name="author" content="Xiangjy">
    
    
        <link rel="icon" href="http://localhost:4000/assets/images/dx.png">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Xiangjy","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"],"image":"dx.png"},"articleBody":"Java 如何实现一个简单的RPC###RPC的实现原理\n正如上一讲所说，RPC主要是为了解决的两个问题：\n\n解决分布式系统中，服务之间的调用问题。\n远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。\n\n还是以计算器Calculator为例，如果实现类CalculatorImpl是放在本地的，那么直接调用即可：\n\n现在系统变成分布式了，CalculatorImpl和调用方不在同一个地址空间，那么就必须要进行远程过程调用：\n\n那么如何实现远程过程调用，也就是RPC呢，一个完整的RPC流程，可以用下面这张图来描述：\n\n其中左边的Client，对应的就是前面的Service A，而右边的Server，对应的则是Service B。下面一步一步详细解释一下。\n\nService A的应用层代码中，调用了Calculator的一个实现类的add方法，希望执行一个加法运算；\n这个Calculator实现类，内部并不是直接实现计算器的加减乘除逻辑，而是通过远程调用Service B的RPC接口，来获取运算结果，因此称之为Stub；\nStub怎么和Service B建立远程通讯呢？这时候就要用到远程通讯工具了，也就是图中的Run-time Library，这个工具将帮你实现远程通讯的功能，比如Java的Socket，就是这样一个库，当然，你也可以用基于Http协议的HttpClient，或者其他通讯工具类，都可以，RPC并没有规定说你要用何种协议进行通讯；\nStub通过调用通讯工具提供的方法，和Service B建立起了通讯，然后将请求数据发给Service B。需要注意的是，由于底层的网络通讯是基于二进制格式的，因此这里Stub传给通讯工具类的数据也必须是二进制，比如calculator.add(1,2)，你必须把参数值1和2放到一个Request对象里头（这个Request对象当然不只这些信息，还包括要调用哪个服务的哪个RPC接口等其他信息），然后序列化为二进制，再传给通讯工具类，这一点也将在下面的代码实现中体现；\n二进制的数据传到Service B这一边了，Service B当然也有自己的通讯工具，通过这个通讯工具接收二进制的请求；\n既然数据是二进制的，那么自然要进行反序列化了，将二进制的数据反序列化为请求对象，然后将这个请求对象交给Service B的Stub处理；\n和之前的Service A的Stub一样，这里的Stub也同样是个“假玩意”，它所负责的，只是去解析请求对象，知道调用方要调的是哪个RPC接口，传进来的参数又是什么，然后再把这些参数传给对应的RPC接口，也就是Calculator的实际实现类去执行。很明显，如果是Java，那这里肯定用到了反射。\nRPC接口执行完毕，返回执行结果，现在轮到Service B要把数据发给Service A了，怎么发？一样的道理，一样的流程，只是现在Service B变成了Client，Service A变成了Server而已：Service B反序列化执行结果-&gt;传输给Service A-&gt;Service A反序列化执行结果 -&gt; 将结果返回给Application，完毕。\n\n理论的讲完了，是时候把理论变成实践了。\n###把理论变成实践\n\n本文的示例代码，可到Github下载。\n\n首先是Client端的应用层怎么发起RPC，ComsumerApp：\n123456public class ComsumerApp &#123;    public static void main(String[] args) &#123;        Calculator calculator = new CalculatorRemoteImpl();        int result = calculator.add(1, 2);    &#125;&#125;\n通过一个CalculatorRemoteImpl，我们把RPC的逻辑封装进去了，客户端调用时感知不到远程调用的麻烦。下面再来看看CalculatorRemoteImpl，代码有些多，但是其实就是把上面的2、3、4几个步骤用代码实现了而已，CalculatorRemoteImpl：\n123456789101112131415161718192021222324252627282930public class CalculatorRemoteImpl implements Calculator &#123;    public int add(int a, int b) &#123;        List&lt;String&gt; addressList = lookupProviders(\"Calculator.add\");        String address = chooseTarget(addressList);        try &#123;            Socket socket = new Socket(address, PORT);            // 将请求序列化            CalculateRpcRequest calculateRpcRequest = generateRequest(a, b);            ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());            // 将请求发给服务提供方            objectOutputStream.writeObject(calculateRpcRequest);            // 将响应体反序列化            ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());            Object response = objectInputStream.readObject();            if (response instanceof Integer) &#123;                return (Integer) response;            &#125; else &#123;                throw new InternalError();            &#125;        &#125; catch (Exception e) &#123;            log.error(\"fail\", e);            throw new InternalError();        &#125;    &#125;&#125;\nadd方法的前面两行，lookupProviders和chooseTarget，可能大家会觉得不明觉厉。\n分布式应用下，一个服务可能有多个实例，比如Service B，可能有ip地址为198.168.1.11和198.168.1.13两个实例，lookupProviders，其实就是在寻找要调用的服务的实例列表。在分布式应用下，通常会有一个服务注册中心，来提供查询实例列表的功能。\n查到实例列表之后要调用哪一个实例呢，只时候就需要chooseTarget了，其实内部就是一个负载均衡策略。\n由于我们这里只是想实现一个简单的RPC，所以暂时不考虑服务注册中心和负载均衡，因此代码里写死了返回ip地址为127.0.0.1。\n代码继续往下走，我们这里用到了Socket来进行远程通讯，同时利用ObjectOutputStream的writeObject和ObjectInputStream的readObject，来实现序列化和反序列化。\n最后再来看看Server端的实现，和Client端非常类似，ProviderApp：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProviderApp &#123;    private Calculator calculator = new CalculatorImpl();    public static void main(String[] args) throws IOException &#123;        new ProviderApp().run();    &#125;    private void run() throws IOException &#123;        ServerSocket listener = new ServerSocket(9090);        try &#123;            while (true) &#123;                Socket socket = listener.accept();                try &#123;                    // 将请求反序列化                    ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());                    Object object = objectInputStream.readObject();                    log.info(\"request is &#123;&#125;\", object);                    // 调用服务                    int result = 0;                    if (object instanceof CalculateRpcRequest) &#123;                        CalculateRpcRequest calculateRpcRequest = (CalculateRpcRequest) object;                        if (\"add\".equals(calculateRpcRequest.getMethod())) &#123;                            result = calculator.add(calculateRpcRequest.getA(), calculateRpcRequest.getB());                        &#125; else &#123;                            throw new UnsupportedOperationException();                        &#125;                    &#125;                    // 返回结果                    ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());                    objectOutputStream.writeObject(new Integer(result));                &#125; catch (Exception e) &#123;                    log.error(\"fail\", e);                &#125; finally &#123;                    socket.close();                &#125;            &#125;        &#125; finally &#123;            listener.close();        &#125;    &#125;&#125;\nServer端主要是通过ServerSocket的accept方法，来接收Client端的请求，接着就是反序列化请求-&gt;执行-&gt;序列化执行结果，最后将二进制格式的执行结果返回给Client。\n就这样我们实现了一个简陋而又详细的RPC。说它简陋，是因为这个实现确实比较挫，在下一小节会说它为什么挫。说它详细，是因为它一步一步的演示了一个RPC的执行流程，方便大家了解RPC的内部机制。\n###为什么说这个RPC实现很挫\n这个RPC实现只是为了给大家演示一下RPC的原理，要是想放到生产环境去用，那是绝对不行的。\n1、缺乏通用性我通过给Calculator接口写了一个CalculatorRemoteImpl，来实现计算器的远程调用，下一次要是有别的接口需要远程调用，是不是又得再写对应的远程调用实现类？这肯定是很不方便的。\n那该如何解决呢？先来看看使用Dubbo时是如何实现RPC调用的：\n12345678@Referenceprivate Calculator calculator;...calculator.add(1,2);...\nDubbo通过和Spring的集成，在Spring容器初始化的时候，如果扫描到对象加了@Reference注解，那么就给这个对象生成一个代理对象，这个代理对象会负责远程通讯，然后将代理对象放进容器中。所以代码运行期用到的calculator就是那个代理对象了。\n我们可以先不和Spring集成，也就是先不采用依赖注入，但是我们要做到像Dubbo一样，无需自己手动写代理对象，怎么做呢？那自然是要求所有的远程调用都遵循一套模板，把远程调用的信息放到一个RpcRequest对象里面，发给Server端，Server端解析之后就知道你要调用的是哪个RPC接口、以及入参是什么类型、入参的值又是什么，就像Dubbo的RpcInvocation：\n12345678910111213public class RpcInvocation implements Invocation, Serializable &#123;    private static final long serialVersionUID = -4355285085441097045L;    private String methodName;    private Class&lt;?&gt;[] parameterTypes;    private Object[] arguments;    private Map&lt;String, String&gt; attachments;    private transient Invoker&lt;?&gt; invoker;\n2、集成Spring在实现了代理对象通用化之后，下一步就可以考虑集成Spring的IOC功能了，通过Spring来创建代理对象，这一点就需要对Spring的bean初始化有一定掌握了。\n3、长连接or短连接总不能每次要调用RPC接口时都去开启一个Socket建立连接吧？是不是可以保持若干个长连接，然后每次有rpc请求时，把请求放到任务队列中，然后由线程池去消费执行？只是一个思路，后续可以参考一下Dubbo是如何实现的。\n4、 服务端线程池我们现在的Server端，是单线程的，每次都要等一个请求处理完，才能去accept另一个socket的连接，这样性能肯定很差，是不是可以通过一个线程池，来实现同时处理多个RPC请求？同样只是一个思路。\n5、服务注册中心正如之前提到的，要调用服务，首先你需要一个服务注册中心，告诉你对方服务都有哪些实例。Dubbo的服务注册中心是可以配置的，官方推荐使用Zookeeper。如果使用Zookeeper的话，要怎样往上面注册实例，又要怎样获取实例，这些都是要实现的。\n6、负载均衡如何从多个实例里挑选一个出来，进行调用，这就要用到负载均衡了。负载均衡的策略肯定不只一种，要怎样把策略做成可配置的？又要如何实现这些策略？同样可以参考Dubbo，Dubbo - 负载均衡\n7、结果缓存每次调用查询接口时都要真的去Server端查询吗？是不是要考虑一下支持缓存？\n8、多版本控制服务端接口修改了，旧的接口怎么办？\n9、异步调用客户端调用完接口之后，不想等待服务端返回，想去干点别的事，可以支持不？\n10、优雅停机服务端要停机了，还没处理完的请求，怎么办？\n……\n诸如此类的优化点还有很多，这也是为什么实现一个高性能高可用的RPC框架那么难的原因。\n当然，我们现在已经有很多很不错的RPC框架可以参考了，我们完全可以借鉴一下前人的智慧。\n###参考\n\n一本很棒的分布式书籍：《大型网站系统与Java中间件实践》\nDubbo 使用文档\nDubbo 源码开发手册\n\n","dateCreated":"2017-09-19T15:42:24+08:00","dateModified":"2019-06-03T00:30:46+08:00","datePublished":"2017-09-19T15:42:24+08:00","description":"","headline":"Java 如何实现一个简单的RPC","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/"},"publisher":{"@type":"Organization","name":"Xiangjy","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"],"image":"dx.png","logo":{"@type":"ImageObject","url":"dx.png"}},"url":"http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/","keywords":"Java"}</script>
    <meta name="description" content="Java 如何实现一个简单的RPC###RPC的实现原理 正如上一讲所说，RPC主要是为了解决的两个问题：  解决分布式系统中，服务之间的调用问题。 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。  还是以计算器Calculator为例，如果实现类CalculatorImpl是放在本地的，那么直接调用即可：  现在系统变成分布式了，CalculatorImpl和调用方不在同">
<meta name="keywords" content="Java">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java 如何实现一个简单的RPC">
<meta property="og:url" content="http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/index.html">
<meta property="og:site_name" content="Xiangjy&#39;s Blog">
<meta property="og:description" content="Java 如何实现一个简单的RPC###RPC的实现原理 正如上一讲所说，RPC主要是为了解决的两个问题：  解决分布式系统中，服务之间的调用问题。 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。  还是以计算器Calculator为例，如果实现类CalculatorImpl是放在本地的，那么直接调用即可：  现在系统变成分布式了，CalculatorImpl和调用方不在同">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7143349-69563e8ebc25c77c.png?imageMogr2/auto-orient/">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7143349-d5f7290907ce3cca.png?imageMogr2/auto-orient/">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7143349-a9db3c3c85194c6e.png?imageMogr2/auto-orient/">
<meta property="og:updated_time" content="2019-06-02T16:30:46.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 如何实现一个简单的RPC">
<meta name="twitter:description" content="Java 如何实现一个简单的RPC###RPC的实现原理 正如上一讲所说，RPC主要是为了解决的两个问题：  解决分布式系统中，服务之间的调用问题。 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。  还是以计算器Calculator为例，如果实现类CalculatorImpl是放在本地的，那么直接调用即可：  现在系统变成分布式了，CalculatorImpl和调用方不在同">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7143349-69563e8ebc25c77c.png?imageMogr2/auto-orient/">
    
    
        
    
    
        <meta property="og:image" content="http://localhost:4000/assets/images/dx.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

    
</head>

    <body>
        <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Xiangjy&#39;s Blog</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/dx.png" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/dx.png" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Xiangjy</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="#search" title="搜索">
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google Plus">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/mailto" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Java 如何实现一个简单的RPC
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2017-09-19T15:42:24+08:00">
	
		    9月 19, 2017
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h1 id="Java-如何实现一个简单的RPC"><a href="#Java-如何实现一个简单的RPC" class="headerlink" title="Java 如何实现一个简单的RPC"></a>Java 如何实现一个简单的RPC</h1><p>###RPC的实现原理</p>
<p>正如上一讲所说，RPC主要是为了解决的两个问题：</p>
<ul>
<li>解决分布式系统中，服务之间的调用问题。</li>
<li>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。</li>
</ul>
<p>还是以计算器Calculator为例，如果实现类CalculatorImpl是放在本地的，那么直接调用即可：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7143349-69563e8ebc25c77c.png?imageMogr2/auto-orient/" alt="img"></p>
<p>现在系统变成分布式了，CalculatorImpl和调用方不在同一个地址空间，那么就必须要进行远程过程调用：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7143349-d5f7290907ce3cca.png?imageMogr2/auto-orient/" alt="img"></p>
<p>那么如何实现远程过程调用，也就是RPC呢，一个完整的RPC流程，可以用下面这张图来描述：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7143349-a9db3c3c85194c6e.png?imageMogr2/auto-orient/" alt="img"></p>
<p>其中左边的Client，对应的就是前面的Service A，而右边的Server，对应的则是Service B。<br>下面一步一步详细解释一下。</p>
<ol>
<li>Service A的应用层代码中，调用了Calculator的一个实现类的add方法，希望执行一个加法运算；</li>
<li>这个Calculator实现类，内部并不是直接实现计算器的加减乘除逻辑，而是通过远程调用Service B的RPC接口，来获取运算结果，因此称之为<strong>Stub</strong>；</li>
<li>Stub怎么和Service B建立远程通讯呢？这时候就要用到<strong>远程通讯工具</strong>了，也就是图中的<strong>Run-time Library</strong>，这个工具将帮你实现远程通讯的功能，比如Java的<strong>Socket</strong>，就是这样一个库，当然，你也可以用基于Http协议的<strong>HttpClient</strong>，或者其他通讯工具类，都可以，<strong>RPC并没有规定说你要用何种协议进行通讯</strong>；</li>
<li>Stub通过调用通讯工具提供的方法，和Service B建立起了通讯，然后将请求数据发给Service B。需要注意的是，由于底层的网络通讯是基于<strong>二进制格式</strong>的，因此这里Stub传给通讯工具类的数据也必须是二进制，比如calculator.add(1,2)，你必须把参数值1和2放到一个Request对象里头（这个Request对象当然不只这些信息，还包括要调用哪个服务的哪个RPC接口等其他信息），然后<strong>序列化</strong>为二进制，再传给通讯工具类，这一点也将在下面的代码实现中体现；</li>
<li>二进制的数据传到Service B这一边了，Service B当然也有自己的通讯工具，通过这个通讯工具接收二进制的请求；</li>
<li>既然数据是二进制的，那么自然要进行<strong>反序列化</strong>了，将二进制的数据反序列化为请求对象，然后将这个请求对象交给Service B的Stub处理；</li>
<li>和之前的Service A的Stub一样，这里的Stub也同样是个“假玩意”，它所负责的，只是去解析请求对象，知道调用方要调的是哪个RPC接口，传进来的参数又是什么，然后再把这些参数传给对应的RPC接口，也就是Calculator的实际实现类去执行。很明显，如果是Java，那这里肯定用到了<strong>反射</strong>。</li>
<li>RPC接口执行完毕，返回执行结果，现在轮到Service B要把数据发给Service A了，怎么发？一样的道理，一样的流程，只是现在Service B变成了Client，Service A变成了Server而已：Service B反序列化执行结果-&gt;传输给Service A-&gt;Service A反序列化执行结果 -&gt; 将结果返回给Application，完毕。</li>
</ol>
<p>理论的讲完了，是时候把理论变成实践了。</p>
<p>###把理论变成实践</p>
<blockquote>
<p>本文的示例代码，可到<a href="https://github.com/hzy38324/simple-rpc" target="_blank" rel="noopener">Github</a>下载。</p>
</blockquote>
<p>首先是Client端的应用层怎么发起RPC，ComsumerApp：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComsumerApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> CalculatorRemoteImpl();</span><br><span class="line">        <span class="keyword">int</span> result = calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过一个CalculatorRemoteImpl，我们把RPC的逻辑封装进去了，客户端调用时感知不到远程调用的麻烦</strong>。下面再来看看CalculatorRemoteImpl，代码有些多，但是其实就是把上面的2、3、4几个步骤用代码实现了而已，CalculatorRemoteImpl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorRemoteImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; addressList = lookupProviders(<span class="string">"Calculator.add"</span>);</span><br><span class="line">        String address = chooseTarget(addressList);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket = <span class="keyword">new</span> Socket(address, PORT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将请求序列化</span></span><br><span class="line">            CalculateRpcRequest calculateRpcRequest = generateRequest(a, b);</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将请求发给服务提供方</span></span><br><span class="line">            objectOutputStream.writeObject(calculateRpcRequest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将响应体反序列化</span></span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            Object response = objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">                <span class="keyword">return</span> (Integer) response;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"fail"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add方法的前面两行，lookupProviders和chooseTarget，可能大家会觉得不明觉厉。</p>
<p>分布式应用下，一个服务可能有多个实例，比如Service B，可能有ip地址为198.168.1.11和198.168.1.13两个实例，lookupProviders，其实就是在寻找要调用的服务的实例列表。在分布式应用下，通常会有一个<strong>服务注册中心</strong>，来提供查询实例列表的功能。</p>
<p>查到实例列表之后要调用哪一个实例呢，只时候就需要chooseTarget了，其实内部就是一个<strong>负载均衡</strong>策略。</p>
<p>由于我们这里只是想实现一个简单的RPC，所以暂时不考虑服务注册中心和负载均衡，因此代码里写死了返回ip地址为127.0.0.1。</p>
<p>代码继续往下走，我们这里用到了Socket来进行远程通讯，同时利用<strong>ObjectOutputStream</strong>的writeObject和<strong>ObjectInputStream</strong>的readObject，来实现序列化和反序列化。</p>
<p>最后再来看看Server端的实现，和Client端非常类似，ProviderApp：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Calculator calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProviderApp().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket listener = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = listener.accept();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将请求反序列化</span></span><br><span class="line">                    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                    Object object = objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"request is &#123;&#125;"</span>, object);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 调用服务</span></span><br><span class="line">                    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> CalculateRpcRequest) &#123;</span><br><span class="line">                        CalculateRpcRequest calculateRpcRequest = (CalculateRpcRequest) object;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"add"</span>.equals(calculateRpcRequest.getMethod())) &#123;</span><br><span class="line">                            result = calculator.add(calculateRpcRequest.getA(), calculateRpcRequest.getB());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回结果</span></span><br><span class="line">                    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                    objectOutputStream.writeObject(<span class="keyword">new</span> Integer(result));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"fail"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            listener.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server端主要是通过ServerSocket的accept方法，来接收Client端的请求，接着就是反序列化请求-&gt;执行-&gt;序列化执行结果，最后将二进制格式的执行结果返回给Client。</p>
<p><strong>就这样我们实现了一个简陋而又详细的RPC。</strong><br>说它简陋，是因为这个实现确实比较挫，在下一小节会说它为什么挫。<br>说它详细，是因为它一步一步的演示了一个RPC的执行流程，方便大家了解RPC的内部机制。</p>
<p>###为什么说这个RPC实现很挫</p>
<p>这个RPC实现只是为了给大家演示一下RPC的原理，要是想放到生产环境去用，那是绝对不行的。</p>
<p>1、缺乏通用性<br>我通过给Calculator接口写了一个CalculatorRemoteImpl，来实现计算器的远程调用，下一次要是有别的接口需要远程调用，是不是又得再写对应的远程调用实现类？这肯定是很不方便的。</p>
<p>那该如何解决呢？先来看看使用Dubbo时是如何实现RPC调用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span></span><br><span class="line"><span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">calculator.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Dubbo通过和Spring的集成，在Spring容器初始化的时候，如果扫描到对象加了@Reference注解，那么就给这个对象生成一个代理对象，这个代理对象会负责远程通讯，然后将代理对象放进容器中。所以代码运行期用到的calculator就是那个代理对象了。</p>
<p>我们可以先不和Spring集成，也就是先不采用依赖注入，但是我们要做到像Dubbo一样，无需自己手动写代理对象，怎么做呢？那自然是要求所有的远程调用都遵循一套模板，<strong>把远程调用的信息放到一个RpcRequest对象里面，发给Server端，Server端解析之后就知道你要调用的是哪个RPC接口、以及入参是什么类型、入参的值又是什么</strong>，就像Dubbo的RpcInvocation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcInvocation</span> <span class="keyword">implements</span> <span class="title">Invocation</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4355285085441097045L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] arguments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; attachments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Invoker&lt;?&gt; invoker;</span><br></pre></td></tr></table></figure>
<p>2、集成Spring<br>在实现了代理对象通用化之后，下一步就可以考虑集成Spring的IOC功能了，通过Spring来创建代理对象，这一点就需要对Spring的bean初始化有一定掌握了。</p>
<p>3、长连接or短连接<br>总不能每次要调用RPC接口时都去开启一个Socket建立连接吧？是不是可以保持若干个长连接，然后每次有rpc请求时，把请求放到任务队列中，然后由线程池去消费执行？只是一个思路，后续可以参考一下Dubbo是如何实现的。</p>
<p>4、 服务端线程池<br>我们现在的Server端，是单线程的，每次都要等一个请求处理完，才能去accept另一个socket的连接，这样性能肯定很差，是不是可以通过一个线程池，来实现同时处理多个RPC请求？同样只是一个思路。</p>
<p>5、服务注册中心<br>正如之前提到的，要调用服务，首先你需要一个服务注册中心，告诉你对方服务都有哪些实例。Dubbo的服务注册中心是可以配置的，官方推荐使用Zookeeper。如果使用Zookeeper的话，要怎样往上面注册实例，又要怎样获取实例，这些都是要实现的。</p>
<p>6、负载均衡<br>如何从多个实例里挑选一个出来，进行调用，这就要用到负载均衡了。负载均衡的策略肯定不只一种，要怎样把策略做成可配置的？又要如何实现这些策略？同样可以参考Dubbo，<a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo - 负载均衡</a></p>
<p>7、结果缓存<br>每次调用查询接口时都要真的去Server端查询吗？是不是要考虑一下支持缓存？</p>
<p>8、多版本控制<br>服务端接口修改了，旧的接口怎么办？</p>
<p>9、异步调用<br>客户端调用完接口之后，不想等待服务端返回，想去干点别的事，可以支持不？</p>
<p>10、优雅停机<br>服务端要停机了，还没处理完的请求，怎么办？</p>
<p>……</p>
<p>诸如此类的优化点还有很多，这也是为什么实现一个高性能高可用的RPC框架那么难的原因。</p>
<p>当然，我们现在已经有很多很不错的RPC框架可以参考了，我们完全可以借鉴一下前人的智慧。</p>
<p>###参考</p>
<ul>
<li>一本很棒的分布式书籍：《大型网站系统与Java中间件实践》</li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo 使用文档</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo 源码开发手册</a></li>
</ul>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Java/">Java</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/09/19/HTML5 惊艳 demo/" data-tooltip="HTML5 惊艳 demo" aria-label="上一篇: HTML5 惊艳 demo">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/09/12/scrapy/" data-tooltip="scrapy" aria-label="下一篇: scrapy">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Xiangjy. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/09/19/HTML5 惊艳 demo/" data-tooltip="HTML5 惊艳 demo" aria-label="上一篇: HTML5 惊艳 demo">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/09/12/scrapy/" data-tooltip="scrapy" aria-label="下一篇: scrapy">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/" title="分享到 Google+">
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://localhost:4000/2017/09/19/java 如何实现一个简单的RPC/">
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/dx.png" alt="作者的图片">
        
            <h4 id="about-card-name">Xiangjy</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END--><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    



    </body>
</html>
